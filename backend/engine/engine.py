from fastapi import UploadFile
from basic_pitch.inference import predict
from music21 import converter
import librosa

import logger, os


log = logger.get()

# Create the directory if it doesn't exist
os.makedirs("processing", exist_ok=True)


class MusicEngine:

    async def Get_music_xml(file: UploadFile) -> (str, bytes):
        try:
            ## step 1: audio to MIDI
            file_path = await create_file(file)

            midi_file_path = create_midi_file(file_path)
            midi_bytes = bytes()
            with open(midi_file_path, "rb") as midi_file:
                midi_bytes = midi_file.read()
            ## step 2: MIDI to musicXML
            mxml_file_path = create_mxml_file(file, file_path, midi_file_path)
            mxml_string = read_file(mxml_file_path)
            return mxml_string, midi_bytes
        except:
            raise Exception("failed to generate sheet music")
        finally:
            delete_file(file_path)
            delete_file(midi_file_path)
            delete_file(mxml_file_path)


## returns MIDI file path
def create_midi_file(file_path: str) -> str:
    # Extract tempo from audio file
    log.info("attempting to extract tempo")
    detected_tempo = extract_audio_tempo(file_path)
    log.info(f"DETECTED TEMPO: {detected_tempo} BPM")
    ## 196 HZ is lowest note on violin
    ## 3520 HZis highest note on violin
    _, midi_data, _ = predict(
        file_path,
        onset_threshold=0.7,
        frame_threshold=0.5,
        minimum_frequency=196,
        maximum_frequency=3520,
        melodia_trick=True,
        midi_tempo=detected_tempo,
    )

    midi_file_path = f"{file_path}-midi.mid"
    log.info(f"attempting to write midi file to {midi_file_path}")
    midi_data.write(midi_file_path)
    return midi_file_path


## returns mxml file path
def create_mxml_file(file: UploadFile, file_path: str, midi_file_path: str) -> str:
    log.info(f"attempting to convert MIDI to musicXML")
    mxml_file_path = f"{file_path}-mxml.musicxml"
    score = converter.parse(midi_file_path)

    score.metadata.title = file.filename
    score.metadata.composer = "Generated by String Scribe"
    for part in score.parts:
        part.keySignature = part.analyze("key")
        # Check if part has any instruments
        instruments = part.getInstruments()
        if instruments:
            # Set the first instrument to violin
            instruments[0].instrumentName = "Violin"
        else:
            # Create instrument if none exists
            from music21.instrument import Violin

            violin = Violin()
            part.append(violin)
    score.write("musicxml", mxml_file_path)
    return mxml_file_path


def extract_audio_tempo(file_path: str) -> int:
    """
    Extract tempo from audio file using librosa.
    Returns the detected BPM as an integer.
    """
    try:
        # Load the audio file
        y, sr = librosa.load(file_path)

        # Extract tempo using librosa's tempo detection
        tempo, _ = librosa.beat.beat_track(y=y, sr=sr)

        # Convert numpy float to Python float, then to int
        detected_tempo = int(float(tempo))

        return detected_tempo

    except Exception as e:
        log.error(f"Error extracting tempo from audio: {e}")
        # Fallback to default tempo
        return 120


def read_file(filePath: str) -> str:
    with open(filePath, "r") as file:
        file_content = file.read()
        return file_content


def delete_file(filePath: str):
    if os.path.exists(filePath):
        os.remove(filePath)
        log.info(f"removed file at path {filePath}")
    else:
        log.info(f"file at path {filePath} not found")


async def create_file(file: UploadFile) -> str:
    log.info(f"creating file {file.filename}")
    out_path = f"./processing/{file.filename}"
    with open(out_path, "wb") as f:
        f.write(await file.read())
    return out_path
