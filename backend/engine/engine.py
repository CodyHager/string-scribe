import secrets, logger, os, librosa
from fastapi import UploadFile
from basic_pitch.inference import predict
from music21 import converter
from music21.instrument import Violin
import yt_dlp

## engine.py holds the main backend logic for transcribing music

log = logger.get()

## Create the processing directory if it doesn't exist
os.makedirs("processing", exist_ok=True)


class MusicEngine:

    async def ProcessMusic(file: UploadFile) -> (str, bytes):
        try:
            ## step 1: audio to MIDI
            file_path = await create_file(file)
            midi_file_path = create_midi_file(file_path)
            midi_bytes = bytes()
            with open(midi_file_path, "rb") as midi_file:
                midi_bytes = midi_file.read()
            ## step 2: MIDI to musicXML
            mxml_file_path = create_mxml_file(file, file_path, midi_file_path)
            mxml_string = read_file(mxml_file_path)
            return mxml_string, midi_bytes
        except:
            raise Exception("failed to generate sheet music")
        finally:
            ## always clean up processing directory
            delete_file(file_path)
            delete_file(midi_file_path)
            delete_file(mxml_file_path)

    async def ProcessYouTube(url: str) -> (str, bytes):
        try:
            # Download audio from YouTube
            file_path = await download_youtube_audio(url)
            # Audio to MIDI
            midi_file_path = create_midi_file(file_path)
            midi_bytes = bytes()
            with open(midi_file_path, "rb") as midi_file:
                midi_bytes = midi_file.read()
            # MIDI to musicXML
            mxml_file_path = create_mxml_file_from_youtube(
                file_path, midi_file_path, url
            )
            mxml_string = read_file(mxml_file_path)
            return mxml_string, midi_bytes
        except Exception as e:
            log.error(f"Failed to process YouTube video: {e}")
            raise Exception(
                f"Failed to generate sheet music from YouTube video: {str(e)}"
            )
        finally:
            # Always clean up processing directory
            delete_file(file_path)
            delete_file(midi_file_path)
            delete_file(mxml_file_path)


# Returns MIDI file path
def create_midi_file(file_path: str) -> str:
    # Extract tempo from audio file
    log.info("attempting to extract tempo")
    detected_tempo = extract_audio_tempo(file_path)
    log.info(f"DETECTED TEMPO: {detected_tempo} BPM")
    # 196 HZ is lowest note on violin
    # 3520 HZis highest note on violin
    _, midi_data, _ = predict(
        file_path,
        onset_threshold=0.7,
        frame_threshold=0.5,
        minimum_frequency=196,
        maximum_frequency=3520,
        melodia_trick=True,
        midi_tempo=detected_tempo,
    )
    midi_file_path = f"{file_path}-midi.mid"
    log.info(f"attempting to write midi file to {midi_file_path}")
    midi_data.write(midi_file_path)
    return midi_file_path


# Returns mxml file path
def create_mxml_file(file: UploadFile, file_path: str, midi_file_path: str) -> str:
    log.info(f"attempting to convert MIDI to musicXML")
    mxml_file_path = f"{file_path}-mxml.musicxml"
    score = converter.parse(midi_file_path)
    # Some customization of the transcription
    score.metadata.title = file.filename
    score.metadata.composer = "Generated by String Scribe"
    for part in score.parts:
        part.keySignature = part.analyze("key")
        # Check if part has any instruments
        instruments = part.getInstruments()
        if instruments:
            # Set the first instrument to violin
            instruments[0].instrumentName = "Violin"
        else:
            # Create instrument if none exists
            violin = Violin()
            part.append(violin)
    score.write("musicxml", mxml_file_path)
    return mxml_file_path


# Returns estimated BPM of the file
def extract_audio_tempo(file_path: str) -> int:
    try:
        # Load the audio file
        y, sr = librosa.load(file_path)
        # Extract tempo using librosa's tempo detection
        tempo, _ = librosa.beat.beat_track(y=y, sr=sr)
        # Convert numpy float to Python float, then to int
        detected_tempo = int(float(tempo))
        return detected_tempo
    except Exception as e:
        log.error(f"Error extracting tempo from audio: {e}")
        # Fallback to default tempo
        return 120


# Helper to read file at filePath
def read_file(filePath: str) -> str:
    with open(filePath, "r") as file:
        file_content = file.read()
        return file_content


# Helper to delete file at filePath
def delete_file(filePath: str):
    if os.path.exists(filePath):
        os.remove(filePath)
        log.info(f"removed file at path {filePath}")
    else:
        log.info(f"file at path {filePath} not found")


# Helper to create file in the processing directory
async def create_file(file: UploadFile) -> str:
    log.info(f"creating file {file.filename}")
    out_path = f"./processing/{file.filename}"
    with open(out_path, "wb") as f:
        f.write(await file.read())
    return out_path


async def download_youtube_audio(url: str) -> str:
    """Download audio from YouTube URL and return file path"""
    # Generate random filename to avoid conflicts
    random_id = secrets.token_urlsafe(8)
    output_path = f"./processing/youtube_{random_id}.mp3"

    ydl_opts = {
        "cookiefile": "./cookies.firefox-private-2.txt",
        ## allows the user to just paste the url
        "noplaylist": True,
        ## get best audio available
        "format": "bestaudio/best",
        ## extract audio from video
        "postprocessors": [
            {
                "key": "FFmpegExtractAudio",
                "preferredcodec": "mp3",
                "preferredquality": "192",
            }
        ],
        "outtmpl": output_path.replace(".mp3", ""),
        ## verbose errors
        "quiet": False,
        "no_warnings": False,
        "verbose": True,
        "print": "cookies",
    }

    log.info(f"Downloading audio from YouTube: {url}")

    try:
        with yt_dlp.YoutubeDL(ydl_opts) as ydl:
            ydl.download([url])

        log.info(f"Downloaded YouTube audio to {output_path}")
        return output_path
    except Exception as e:
        log.error(f"Failed to download YouTube audio: {e}")
        raise Exception(f"Failed to download audio from YouTube: {str(e)}")


def create_mxml_file_from_youtube(file_path: str, midi_file_path: str, url: str) -> str:
    """Create musicXML file from YouTube download (same as create_mxml_file but with YouTube title)"""
    log.info(f"attempting to convert MIDI to musicXML")
    mxml_file_path = f"{file_path}-mxml.musicxml"
    score = converter.parse(midi_file_path)

    # Some customization of the transcription
    score.metadata.title = f"YouTube: {url}"
    score.metadata.composer = "Generated by String Scribe"
    for part in score.parts:
        part.keySignature = part.analyze("key")
        # Check if part has any instruments
        instruments = part.getInstruments()
        if instruments:
            # Set the first instrument to violin
            instruments[0].instrumentName = "Violin"
        else:
            # Create instrument if none exists
            violin = Violin()
            part.append(violin)
    score.write("musicxml", mxml_file_path)
    return mxml_file_path
